package com.didi.virtualapk

import com.android.build.gradle.BaseExtension
import com.android.build.gradle.internal.VariantManager
import com.android.build.gradle.internal.api.ApplicationVariantImpl
import com.android.build.gradle.internal.plugins.AppPlugin
import com.android.build.gradle.internal.res.LinkApplicationAndroidResourcesTask
import com.android.build.gradle.internal.scope.VariantScopeImpl
import com.android.build.gradle.internal.tasks.ProguardTask

import com.android.build.gradle.tasks.MergeSourceSetFolders
import com.android.utils.StringHelper
import com.didi.virtualapk.hooker.MergeAssetsHooker
import com.didi.virtualapk.hooker.MergeManifestsHooker
import com.didi.virtualapk.hooker.PrepareDependenciesHooker
import com.didi.virtualapk.tasks.AssemblePlugin
import com.didi.virtualapk.transform.MinifiedJarStripClassProcessor
import com.didi.virtualapk.transform.StripClassAndResTransform
import com.didi.virtualapk.transform.StripClassesFromDexProcessor
import com.tencent.shadow.core.transform.ShadowTransform
import com.tencent.shadow.core.transform_kit.AndroidClassPoolBuilder
import com.tencent.shadow.core.transform_kit.ClassPoolBuilder
import com.tencent.tinker.build.gradle.task.TinkerProguardConfigAction

import com.tencent.tinker.build.gradle.Compatibilities
import com.tencent.tinker.build.gradle.task.TinkerProguardConfigAction
import javassist.ClassPool
import org.gradle.api.GradleException
import org.gradle.api.InvalidUserDataException
import org.gradle.api.Plugin
import org.gradle.api.Project
import org.gradle.api.Task
import org.gradle.api.artifacts.Configuration
import org.gradle.api.artifacts.DependencyResolveDetails
import org.gradle.api.artifacts.ResolutionStrategy

/**
 * VirtualAPK gradle plugin for plugin project
 *
 * @author zhengtao
 */

class VAPlugin implements Plugin<Project> {

    protected Project project
    VariantManager variantManager
    VAExtension virtualApk

    boolean checkVariantFactoryInvoked
    //Files be retained after host apk build
    //private def hostFileNames = ['versions', 'R.txt', 'mapping.txt', 'versions.txt', 'Host_R.txt'] as Set

    /**
     * Stores files generated by the host side and is used when building plugin apk
     */
    private def hostDir
    private boolean checked
    BaseExtension android

    AppPlugin appPlugin
    def androidClassPoolBuilder

    @Override
    void apply(final Project project) {
        this.project = project
        virtualApk = project.extensions.create('virtualApk', VAExtension)
        VAExtension.vaContext.VAExtension = virtualApk
        hostDir = new File(project.rootProject.buildDir, "host")
        if (!hostDir.exists()) {
            hostDir.mkdirs()
        }
        virtualApk.mapping = new File(hostDir, "/mapping.txt")
        virtualApk.hostDependenceFile = new File(hostDir, "versions.txt")
        def startParameter = project.gradle.startParameter.taskNames[0]
        if (startParameter != null && startParameter.contains(":")) {
            startParameter = startParameter.split(":").find {
                if (it.startsWith("assemble")) {
                    return it
                }
            }
        }
//        project.configurations.
        println "BasePlugin.apply startParameter = " + startParameter
        android = project.extensions.getByName("android")
        appPlugin = project.plugins.getPlugin(AppPlugin.class)

        android.registerTransform( new StripClassAndResTransform(project))
        def lateInitBuilder = new ClassPoolBuilder() {
            @Override
            ClassPool build() {
                return  androidClassPoolBuilder.build()
            }
        }
        def shadowTransform = new ShadowTransform(project, lateInitBuilder)
        android.registerTransform(shadowTransform)
        println "project useTransformReplaceClass  = ${virtualApk.vaContext.VAExtension.useTransformReplaceClass}"
        project.afterEvaluate {
            shadowTransform.setApplyTransform(virtualApk.vaContext.VAExtension.useTransformReplaceClass)
            def nativeLibs = new File(hostDir, "nativeLibs.txt")
            println "VAPlugin.apply stripResource = ${virtualApk.vaContext.VAExtension.stripResource}"
            if (nativeLibs.exists()) {
                nativeLibs.eachLine {
                    println "VAPlugin.apply packagingOptions.exclude : " + it
                    android.packagingOptions.exclude(it)
                }
            }
            println "project.afterEvaluate virtualApk.stripResource = " + virtualApk.vaContext.VAExtension.stripResource
            initAndroidClassPoolBuilder(project, android)
            println "BasePlugin.apply virtualApk.packageId = " + virtualApk.packageId
            AppPlugin appPlugin = project.plugins.findPlugin(AppPlugin)
            variantManager = appPlugin.variantManager
            android.defaultConfig.buildConfigField("int", "PACKAGE_ID", "0x" + Integer.toHexString(virtualApk.packageId))

            registerTaskHookers()
            createTasks(project)

            if (android.dataBinding.enabled) {
                project.dependencies.add('annotationProcessor', project.files(jarPath.absolutePath))
            }

            android.applicationVariants.each { ApplicationVariantImpl variant ->

                virtualApk.with {
                    VAExtension.VAContext vaContext = getVaContext()
                    vaContext.packageName = variant.applicationId
                    vaContext.packagePath = vaContext.packageName.replace('.'.charAt(0), File.separatorChar)
                    vaContext.hostSymbolFile = new File(hostDir, "Host_R.txt")
                }
            }
        }
    }

    private void initAndroidClassPoolBuilder(Project project, BaseExtension baseExtension) {
        def sdkDirectory = android.sdkDirectory
        def compileSdkVersion = android.compileSdkVersion
        def androidJarPath = "platforms/${compileSdkVersion}/android.jar"
        def androidJar = new File(sdkDirectory, androidJarPath)

        def classLoader = Thread.currentThread().contextClassLoader
        def coreJar = "${project.rootProject.rootDir.path}/libs/va-core.jar"
        ArrayList<URL> urlList = new ArrayList<URL>();
        def coreJarFile = new File(coreJar)
        println "add coreJarFile [${coreJarFile}] to classloader"
        if (!coreJarFile.exists()) {
            println "coreJarFile not exist"
        }
        urlList.add(coreJarFile.toURI().toURL())
        def urls = urlList.toArray(new URL[]{});
//
        classLoader = new URLClassLoader(urls, classLoader)
//        classLoader = Thread.currentThread().contextClassLoader

        try {
            def loadClass =
                    classLoader.loadClass("com.didi.virtualapk.internal.PackageManagerInvokeRedirect")
            println("found PackageManagerInvokeRedirect")
        } catch (Exception ignored) {
            println("not found PackageManagerInvokeRedirect")
        }

        androidClassPoolBuilder = new AndroidClassPoolBuilder(project, classLoader, androidJar)
    }

    private void createTasks(Project project) {
        android.applicationVariants.each { ApplicationVariantImpl variant ->
//            if ('release' != variant.buildType.name){
//                println " AssemblePlugin createTasks DEBUG RETURN "
//                return
//            }
            println "AssemblePlugin createTasks Release  Continue"
            def assembleTaskName = StringHelper.appendCapitalized("assemble", variant.name) + "Plugin"
            final def configAction = new AssemblePlugin(project, variant)
            def task = project.tasks.create(assembleTaskName)
            task.configure {
                configAction.configure(task)
            }
            task.doFirst {
                configAction.execute()
            }
        }
    }

    void registerTaskHookers() {
        android.applicationVariants.all { ApplicationVariantImpl appVariant ->
/*            if ('release' != appVariant.buildType.name){
                println "AssemblePlugin registerTaskHookers DEBUG RETURN "
                return
            }*/
            project.task("StripClassesFromDexWith${appVariant.name.capitalize()}").doLast {
                new StripClassesFromDexProcessor(project, appVariant).doAction()
            }
            def preBuildTask = appVariant.getVariantData().taskContainer.preBuildTask.get()
            preBuildTask.doLast {
                def prepareDependenciesHooker = new PrepareDependenciesHooker(project, appVariant)
                prepareDependenciesHooker.beforeTaskExecute()
                prepareDependenciesHooker.afterTaskExecute()
            }
//:mainpage:processOttTypeReleaseMainManifest
// :mainpage:processOttTypeReleaseManifest
// :mainpage:processOttTypeReleaseManifestForPackage
            def processMainManifest = project.tasks.findByName("process" + appVariant.name.capitalize() + "MainManifest")
            processMainManifest.doFirst {
                println "kwey- processMainManifest doFirst"+processMainManifest.class.toString()
               new MergeManifestsHooker(project,appVariant).beforeTaskExecute(processMainManifest)
            }
            def processManifest = project.tasks.findByName("process" + appVariant.name.capitalize() + "Manifest")
            processManifest.doLast {
                println "kwey- processManifest dolast"+processManifest.class.toString()
                new MergeManifestsHooker(project,appVariant).afterTaskExecute(processManifest)
            }


            LinkApplicationAndroidResourcesTask processResTask = appVariant.getVariantData().taskContainer.processAndroidResTask.get()
            new TaskHookerManager(project).registerProcessResourceTask(processResTask, appVariant)
            MergeSourceSetFolders mergeAssetsTask = appVariant.getVariantData().taskContainer.mergeAssetsTask.get()
            mergeAssetsTask.doLast {
                new MergeAssetsHooker(project, appVariant).beforeTaskExecute(mergeAssetsTask)
            }

            boolean foundObfuscateTask = false
            //mapping
            def minifyR8Task = project.tasks.findByName("minify" + appVariant.name.capitalize() + "WithR8")
            if (minifyR8Task != null && minifyR8Task.enabled) {
                foundObfuscateTask = true
                println "minifyR8Task = " + minifyR8Task.class
                println "vaContext.VAExtension.stripClass = " + virtualApk.vaContext.VAExtension.stripClass
                if (virtualApk.vaContext.VAExtension.stripClass) {
                    minifyR8Task.doLast {
//                        new StripClassesFromDexProcessor(project, appVariant).doAction()
                    }
                }
                throw new GradleException("currently not support R8")
            }
            ProguardTask minifyTask = project.tasks.findByName("minify" + appVariant.name.capitalize() + "WithProguard")
            if (minifyTask != null && minifyTask.enabled) {
                println "minifyTask = " + minifyTask.class
                foundObfuscateTask = true
                if (virtualApk.vaContext.VAExtension.stripClass) {
                    println "stripClass = " + virtualApk.vaContext.VAExtension.stripClass
                    minifyTask.doLast {
                        new MinifiedJarStripClassProcessor(project, appVariant).doAction()
                    }
                }
            }
            println "is foundObfuscateTask = " + foundObfuscateTask
            if (!foundObfuscateTask) {
//                if (virtualApk.vaContext.VAExtension.stripClass) {
//                    def mergeDexTask = project.tasks.findByName("mergeDex" + appVariant.name.capitalize())
//                    mergeDexTask.doLast {
//                        println "dexBuilderTask = " + mergeDexTask.class
//                        new StripClassesFromDexProcessor(project, appVariant).doAction()
//                    }
//                }
            }

            if (virtualApk.applyHostMapping) {
                println "applyHostMapping"
                if (appVariant.buildType.name.endsWithIgnoreCase("release")) {
                    def proguardTask = Compatibilities.getObfuscateTask(project, appVariant)
                    proguardTask.doFirst(new TinkerProguardConfigAction(project, appVariant))
                }
//                    R8Task proguardTask = project.tasks["minify${appVariant.name.capitalize()}WithR8"]
            }
        }
    }

    /**
     * Check the plugin apk related config infos
     */
    private void checkConfig() {
        if (checked) {
            return
        }
        checked = true

        int packageId = virtualApk.packageId
        if (packageId == 0) {
            def err = new StringBuilder('you should set the packageId in build.gradle,\n ')
            err.append('please declare it in application project build.gradle:\n')
            err.append('    virtualApk {\n')
            err.append('        packageId = 0xXX \n')
            err.append('    }\n')
            err.append('apply for the value of packageId.\n')
            throw new InvalidUserDataException(err.toString())
        }
        if (packageId >= 0x7f || packageId <= 0x01) {
            throw new IllegalArgumentException('the packageId must be in [0x02, 0x7E].')
        }

        String targetHost = virtualApk.targetHost
        if (!targetHost) {
            def err = new StringBuilder('\nyou should specify the targetHost in build.gradle, e.g.: \n')
            err.append('    virtualApk {\n')
            err.append('        //when target Host in local machine, value is host application directory\n')
            err.append('        targetHost = ../xxxProject/app \n')
            err.append('    }\n')
            throw new InvalidUserDataException(err.toString())
        }

        File hostLocalDir = new File(targetHost)
        if (!hostLocalDir.exists()) {
            def err = "The directory of host application doesn't exist! Dir: ${hostLocalDir.path}"
            throw new IllegalStateException(err)
        }

//        File hostR = new File(hostLocalDir, "build/VAHost/Host_R.txt")
//        if (hostR.exists()) {
//            def dst = new File(hostDir, "Host_R.txt")
//            use(FileBinaryCategory) {
//                dst << hostR
//            }
//        } else {
//            def err = new StringBuilder("Can't find ${hostR.path}, please check up your host application\n")
//            err.append("  need apply com.didi.virtualapk.host in build.gradle of host application\n ")
//            throw new InvalidUserDataException(err.toString())
//        }

//        File hostVersions = new File(hostLocalDir, "build/VAHost/versions.txt")
//        if (hostVersions.exists()) {
//            def dst = new File(hostDir, "versions.txt")
//            use(FileBinaryCategory) {
//                dst << hostVersions
//            }
//        } else {
//            def err = new StringBuilder("Can't find ${hostVersions.path}, please check up your host application\n")
//            err.append("  need apply com.didi.virtualapk.host in build.gradle of host application \n")
//            throw new InvalidUserDataException(err.toString())
//        }

//        File hostMapping = new File(hostLocalDir, "build/VAHost/mapping.txt")
//        if (hostMapping.exists()) {
//            def dst = new File(hostDir, "mapping.txt")
//            use(FileBinaryCategory) {
//                dst << hostMapping
//            }
//        }

//        AppPlugin appPlugin = project.plugins.findPlugin(AppPlugin)
//        ProjectOptions projectOptions = Reflect.on(appPlugin).field('projectOptions').get()
//        if (projectOptions.get(BooleanOption.ENABLE_DEX_ARCHIVE)) {
//            throw new InvalidUserDataException("Can't using incremental dexing mode, please add 'android.useDexArchive=false' in gradle.properties of :${project.name}.")
//        }
//        project.ext.set('android.useDexArchive', false)

    }


    File getJarPath() {
        URL url = this.class.getResource("")
        int index = url.path.indexOf('!')
        if (index < 0) {
            index = url.path.length()
        }
        return project.file(url.path.substring(0, index))
    }

    private boolean evaluateBuildingPlugin(AppPlugin appPlugin, Project project) {
        boolean isBuildingPlugin = false

        def startParameter = project.gradle.startParameter
        def targetTasks = startParameter.taskNames
        println "[BasePlugin.evaluateBuildingPlugin] targetTasks=" + targetTasks
        if (targetTasks.size() > 0) {
            isBuildingPlugin = targetTasks[0].startsWith("assemble") && targetTasks[0].endsWith("Plugin")
        }

        println "[BasePlugin.evaluateBuildingPlugin] isBuildingPlugin=" + isBuildingPlugin
        def pluginTasks = ['assemblePlugin'] as List<String>
        println "[BasePlugin.evaluateBuildingPlugin] appPlugin.variantManager.variantScopes = " + appPlugin.variantManager.variantScopes

        appPlugin.variantManager.variantScopes.each {
            VariantScopeImpl scope = it as VariantScopeImpl
            println "[BasePlugin.evaluateBuildingPlugin] scope.variantData.name = " + scope.variantData.name
        }
        appPlugin.variantManager.buildTypes.each {
            def buildType = it.value.buildType
            println "[BasePlugin.evaluateBuildingPlugin] buildType = " + buildType

            appPlugin.variantManager.variantScopes.each {
//                String variantName
//                if (project.extensions.extraProperties.get(Constants.GRADLE_3_1_0)) {
//                    variantName = Reflect.on('com.android.build.gradle.internal.core.VariantConfiguration')
//                            .call('computeFullName', it.key, buildType, VariantType.DEFAULT, null)
//                            .get()
//                } else {
//                    variantName = Reflect.on('com.android.builder.core.VariantConfiguration')
//                            .call('computeFullName', it.key, buildType, VariantType.DEFAULT, null)
//                            .get()
//                }
                println "[BasePlugin.evaluateBuildingPlugin] it.fullVariantName.capitalize() = " + it.fullVariantName.capitalize()
//                def variantPluginTaskName = createPluginTaskName("assemble${it.fullVariantName.capitalize()}Plugin".toString())
//                pluginTasks.add(variantPluginTaskName)
            }
        }

//        pluginTasks.each {
//            Log.i 'VAPlugin', "pluginTask: ${it}"
//        }

//        NameMatcher nameMatcher = new NameMatcher()
//        targetTasks.every {
//            int index = it.lastIndexOf(":");
//            String task = index >= 0 ? it.substring(index + 1) : it
//            String taskName = nameMatcher.find(task, pluginTasks)
//            if (taskName != null) {
////                Log.i 'VAPlugin', "Found task name '${taskName}' by given name '${it}'"
//                isBuildingPlugin = true
//                return false
//            }
//            return true
//        }

        return isBuildingPlugin
    }

    private void checkPluginDependVersion(boolean isBuildingPlugin) {
        HashSet<String> replacedSet = [] as HashSet
        project.rootProject.subprojects { Project p ->
            p.configurations.all { Configuration configuration ->
                configuration.resolutionStrategy { ResolutionStrategy resolutionStrategy ->
                    resolutionStrategy.eachDependency { DependencyResolveDetails details ->
                        if (!isBuildingPlugin) {
                            return
                        }

                        checkConfig()

                        def hostDependency = virtualApk.hostDependencies.get("${details.requested.group}:${details.requested.name}")
                        if (hostDependency != null) {
                            if ("${details.requested.version}" != "${hostDependency['version']}") {
                                String key = "${p.name}:${details.requested}"
                                if (!replacedSet.contains(key)) {
                                    replacedSet.add(key)
                                    if (virtualApk.forceUseHostDependences) {
//                                        Log.i 'Dependencies', "ATTENTION: Replaced module [${details.requested}] in project(:${p.name})'s configuration to host version: [${hostDependency['version']}]!"
                                    } else {
                                        virtualApk.addWarning "WARNING: [${details.requested}] in project(:${p.name})'s configuration will be occupied by Host App! Please change it to host version: [${hostDependency['group']}:${hostDependency['name']}:${hostDependency['version']}]."
                                        virtualApk.setFlag('tip.forceUseHostDependences', true)
                                    }
                                }

                                if (virtualApk.forceUseHostDependences) {
                                    details.useVersion(hostDependency['version'])
                                }
                            }
                        }
                    }
                }
            }
        }
    }

}
